/* Copyright 2010, 2017, Oracle and/or its affiliates. All rights reserved. */
package toystore.model.businessobjects;
import java.sql.PreparedStatement;
import oracle.jbo.server.EntityCache;
//  ---------------------------------------------------------------------
//  ---    File generated by Oracle ADF Business Components Design Time.
//  ---    Custom code may be added to this class.
//  ---    Warning: Do not modify method signatures of generated methods.
//  ---------------------------------------------------------------------
public class InventoryCollImpl extends EntityCache {
  private static final String NOWAIT_TRAILER = " NOWAIT";

  /**
   *
   *  This is the default constructor (do not remove)
   */
  public InventoryCollImpl() {}

  /**
   * Force the lock query to not use the NOWAIT option for just this one
   * entity object. Since we are decrementing the inventory of items
   * during the ToyStoreService.finalizeOrder() method in sorted part
   * number order, and since there could be contention on the inventory
   * table whose quantities we're decrementing, we let the database
   * implement the wait-until-lock-can-be-acquired behavior, rather than
   * coding it in Java to simplify things.
   *
   * @return PreparedStatement with the sql statement provided
   * @param noRowsPrefetch Fetch size
   * @param lock True if we're performing a row lock for this entity
   * @param sqlString SQL String to prepare
   */
  protected PreparedStatement createPreparedStatement(String sqlString,
    boolean lock, int noRowsPrefetch) {
    if (lock) {
      int nowaitStart = sqlString.lastIndexOf(NOWAIT_TRAILER);
      if (nowaitStart > 0) {
        sqlString = sqlString.substring(0, nowaitStart);
      }
    }
    return super.createPreparedStatement(sqlString, lock, noRowsPrefetch);
  }
}
