/* Copyright 2010, 2017, Oracle and/or its affiliates. All rights reserved. */
package demo.model.businessobjects;
import com.sun.java.util.collections.ArrayList;
import com.sun.java.util.collections.List;
import demo.fwkext.CustomEntityImpl;
import demo.model.jpub.DeptT;
import demo.model.jpub.EmpT;
import demo.model.jpub.EmpTList;
import java.sql.SQLException;
import oracle.jbo.DMLException;
import oracle.jbo.Key;
import oracle.jbo.RowIterator;
import oracle.jbo.domain.DBSequence;
import oracle.jbo.server.AttributeDefImpl;
import oracle.jbo.server.Entity;
import oracle.jbo.server.EntityDefImpl;
import oracle.jbo.server.TransactionEvent;
//  ---------------------------------------------------------------------
//  ---    File generated by Oracle ADF Business Components Design Time.
//  ---    Custom code may be added to this class.
//  ---    Warning: Do not modify method signatures of generated methods.
//  ---------------------------------------------------------------------
public class DeptImpl extends CustomEntityImpl {
    public static final int DEPTNO = 0;
    public static final int DNAME = 1;
    public static final int LOC = 2;
    public static final int EMP = 3;
    private static EntityDefImpl mDefinitionObject;

  /**
   *
   *  This is the default constructor (do not remove)
   */
  public DeptImpl() {}

    /**Retrieves the definition object for this instance class.
     */
    public static synchronized EntityDefImpl getDefinitionObject() {
        if (mDefinitionObject == null) {
            mDefinitionObject = (EntityDefImpl)EntityDefImpl.findDefObject("demo.model.businessobjects.Dept");
        }
        return mDefinitionObject;
    }
    private DeptT deptTForThisDeptImpl = null;

    /**
     *
     *  Gets the attribute value for Deptno, using the alias name Deptno
     */
  public DBSequence getDeptno() {
    return (DBSequence) getAttributeInternal(DEPTNO);
  }
  /**
   *
   *  Gets the attribute value for Dname, using the alias name Dname
   */
  public String getDname() {
    return (String) getAttributeInternal(DNAME);
  }
  /**
   *
   *  Sets <code>value</code> as the attribute value for Dname
   */
  public void setDname(String value) {
    setAttributeInternal(DNAME, value);
  }
  /**
   *
   *  Gets the attribute value for Loc, using the alias name Loc
   */
  public String getLoc() {
    return (String) getAttributeInternal(LOC);
  }
  /**
   *
   *  Sets <code>value</code> as the attribute value for Loc
   */
  public void setLoc(String value) {
    setAttributeInternal(LOC, value);
  }
  /**
   *
   *  getAttrInvokeAccessor: generated method. Do not modify.
   */
  protected Object getAttrInvokeAccessor(int index, AttributeDefImpl attrDef)
    throws Exception {
        switch (index) {
        case DEPTNO:
            return getDeptno();
        case DNAME:
            return getDname();
        case LOC:
            return getLoc();
        case EMP:
            return getEmp();
        default:
            return super.getAttrInvokeAccessor(index, attrDef);
        }
    }
  /**
   *
   *  setAttrInvokeAccessor: generated method. Do not modify.
   */
  protected void setAttrInvokeAccessor(int index, Object value,
    AttributeDefImpl attrDef) throws Exception {
        switch (index) {
        case DNAME:
            setDname((String)value);
            return;
        case LOC:
            setLoc((String)value);
            return;
        default:
            super.setAttrInvokeAccessor(index, value, attrDef);
            return;
        }
    }
  /**
   *
   *  Gets the associated entity oracle.jbo.RowIterator
   */
  public RowIterator getEmp() {
    return (RowIterator) getAttributeInternal(EMP);
  }
    // ------------[Begin User-Written Code]------------------------------
  /**
   * This method returns a DeptT class for the current DeptImpl entity object,
   * including its nested EmpTList-valued "emps" attribute containing a list
   * of any modified, composed Emps in the current transaction.
   * 
   * The "terminated" attribute in the EmpT class is used to communicate
   * to the stored procedure that the particular employee should be
   * terminated/removed.
   * 
   * NOTE: It's important to understand that the getTransactionListenersList()
   * ====  is only able to return us automatically a list of modified 
   *       "children" entities when the parent and child entities are related
   *       by an association that has been marked as a "Composition".
   *       
   * @return 
   */
  private DeptT deptTForDeptImpl() {
    try {
      if (deptTForThisDeptImpl != null) {
        return deptTForThisDeptImpl;
      }
      DeptT d = new DeptT();
      d.setDeptno(bigDecimal(getDeptno()));
      d.setDname(getDname());
      d.setLoc(getLoc());
      List changedEmps = getTransactionListenersList();
      if ((changedEmps != null) && (changedEmps.size() > 0)) {
        int numChangedEmps = changedEmps.size();
        EmpT[] emps = new EmpT[numChangedEmps];
        for (int j = 0; j < numChangedEmps; j++) {
          EmpImpl changedEmpImpl = (EmpImpl) changedEmps.get(j);
          EmpT changedEmpT = new EmpT(bigDecimal(changedEmpImpl.getEmpno()),
              changedEmpImpl.getEname(), changedEmpImpl.getJob(),
              bigDecimal(changedEmpImpl.getMgr()),
              timestamp(changedEmpImpl.getHiredate()),
              bigDecimal(changedEmpImpl.getSal()),
              bigDecimal(changedEmpImpl.getComm()),
              bigDecimal(changedEmpImpl.getDeptno()),
              (changedEmpImpl.getEntityState() == Entity.STATUS_DELETED) ? "Y"
                                                                         : "N");
          emps[j] = changedEmpT;
        }
        d.setEmps(new EmpTList(emps));
      }
      deptTForThisDeptImpl = d;
      return deptTForThisDeptImpl;
    }
    catch (SQLException s) {
      return null;
    }
  }
  /**
   * Helper method to refresh the Empno primary key of any newly created
   * employee rows. In this example, their primary key is assigned by
   * a database sequence. Retrieving the new value could be done 
   * declaratively for entity objects against regular tables simply by
   * marking the attribute to be of type DBSequence, but since we're
   * taking over the doDML() processing here, we need to perform the
   * refresh-after-insert processing ourselves.
   * 
   * The signal that an employee row is new is that its DBSequence-valued
   * Empno attribute currently will have the temporary negative value.
   * 
   * @param d
   * @param modifiedEmployees
   */
  void handleRefreshingAnyNewEmployees(ArrayList modifiedEmployees, DeptT d) {
    if (modifiedEmployees != null) {
      int modEntityCount = modifiedEmployees.size();
      int dEmpsCounts = 0;
      try {
        EmpTList emps = d.getEmps();
        if ((emps != null) && (emps.getArray() != null)) {
          dEmpsCounts = d.getEmps().length();
        }
      }
      catch (SQLException e) {
        // Ignore
      }
      for (int j = 0; j < modEntityCount; j++) {
        EmpImpl e = (EmpImpl) modifiedEmployees.get(j);
        if (e.getEmpno().getSequenceNumber().longValue() < 0) {
          try {
            e.refreshEmpNo(d.getEmps().getElement(j).getEmpno());
          }
          catch (SQLException ex) {
            // Ignore
          }
        }
      }
    }
  }
  /**
   * Handle the insert of a Dept by invoking DEPT_SERVICE.ADD_DEPT()
   */
  void handleStoredProcInsert() {
    DeptT d = deptTForDeptImpl();
    ArrayList modifiedEmployees = getTransactionListenersList();
    d = (DeptT) callInOutOraDataProcedure(DML_INSERT,
        "dept_service.add_dept(?)", d, d._SQL_TYPECODE, d._SQL_NAME);
    try {
      populateAttribute(DEPTNO, new DBSequence(d.getDeptno()), true, false,
        false);
      handleRefreshingAnyNewEmployees(modifiedEmployees, d);
    }
    catch (SQLException s) {
      throw new DMLException(DML_INSERT, "getDeptno()", s);
    }
  }
  /**
   * Handle the update of a Dept by invoking DEPT_SERVICE.UPDATE_DEPT()
   */
  void handleStoredProcUpdate() {
    DeptT d = deptTForDeptImpl();
    ArrayList modifiedEmployees = getTransactionListenersList();
    d = (DeptT) callInOutOraDataProcedure(DML_INSERT,
        "dept_service.update_dept(?)", d, d._SQL_TYPECODE, d._SQL_NAME);
    /*
     * Refresh the Empno primary key attribute if necessary
     * for any employees that were new.
     */
    handleRefreshingAnyNewEmployees(modifiedEmployees, d);
  }
  /**
   * Handle the delete of a Dept by invoking DEPT_SERVICE.REMOVE_DEPT()
   */
  void handleStoredProcDelete() {
    callStoredProcedure("dept_service.remove_dept(?);",
      new Object[] { getDeptno().getSequenceNumber() });
  }
  /**
   * Overridden framework method to change how DML operations are performed
   * for this entity. Inside the helper methods we illustrate how we
   * can invoke a single "Dept-level" stored procedure that updates
   * both a Dept and any composed emps that have changed.
   * 
   * @param e
   * @param operation
   */
  public void doDML(int operation, TransactionEvent e) {
    switch (operation) {
    case DML_INSERT: {
      handleStoredProcInsert();
      break;
    }
    case DML_UPDATE: {
      handleStoredProcUpdate();
      break;
    }
    case DML_DELETE: {
      handleStoredProcDelete();
      break;
    }
    }
  }
  /**
   * Overridden framework method to force the doDML() to occur
   * on a DeptImpl even if it was not modified in the case that
   * it was added to the transaction list (and hence had its
   * postChanges() method called on it during post-processing)
   * due to the fact that one of its composed, children entities
   * was created, removed, or modified.
   * 
   * @param e
   */
  public void postChanges(TransactionEvent e) {
    try {
      byte stateBeforePostChanges = getEntityState();
      deptTForThisDeptImpl = deptTForDeptImpl();
      super.postChanges(e);
      /**
       * If the DeptImpl was unmodified (for example, because only
       * a "child" EmpImpl has been created/updated/deleted, then
       * it will not have its doDML() called on it. So, we force
       * the doDML() to be called since our API's only operate
       * on the containing "Dept" object
       */
      if (stateBeforePostChanges == Entity.STATUS_UNMODIFIED) {
        doDML(DML_UPDATE, e);
      }
    }
    finally {
      deptTForThisDeptImpl = null;
    }
  }

    /**Creates a Key object based on given key constituents
     */
    public static Key createPrimaryKey(DBSequence deptno) {
        return new Key(new Object[]{deptno});
    }
}
