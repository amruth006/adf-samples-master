/* Copyright 2010, 2017, Oracle and/or its affiliates. All rights reserved. */
// $Header: /cvs/ADFToyStoreJSF/ToyStoreModel/src/toystore/model/services/ToyStoreServiceImpl.java,v 1.1.1.1 2006/01/26 21:47:22 steve Exp $
package toystore.model.services;
//  ---------------------------------------------------------------
//  ---    File generated by Oracle Business Components for Java.
//  ---------------------------------------------------------------
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import oracle.jbo.Key;
import oracle.jbo.Row;
import oracle.jbo.RowInconsistentException;
import oracle.jbo.RowSetIterator;
import oracle.jbo.Session;
import oracle.jbo.ViewObject;
import oracle.jbo.domain.Number;
import oracle.jbo.server.Entity;
import oracle.jbo.server.EntityDefImpl;
import oracle.jbo.server.ViewLinkImpl;
import oracle.jbo.server.ViewObjectImpl;
import toystore.fwk.model.dataaccess.PropertyFileBasedLookupViewObjectImpl;
import toystore.fwk.model.service.ToyStoreApplicationModuleImpl;
import toystore.model.businessobjects.AccountImpl;
import toystore.model.businessobjects.InventoryImpl;
import toystore.model.businessobjects.ItemImpl;
import toystore.model.dataaccess.AccountsImpl;
import toystore.model.dataaccess.AccountsRowImpl;
import toystore.model.dataaccess.ItemsForSaleImpl;
import toystore.model.dataaccess.LineItemsRowImpl;
import toystore.model.dataaccess.OrdersRowImpl;
import toystore.model.dataaccess.ReviewOrderImpl;
import toystore.model.dataaccess.ShoppingCartImpl;
import toystore.model.dataaccess.ShoppingCartRowImpl;
import toystore.model.services.common.ToyStoreService;
/**
 * This class contains all business logic related to the ADF ToyStore
 * application. It is exposed as a data control through the ADF binding
 * layer to clients.
 *
 * @author Steve Muench
 */
public class ToyStoreServiceImpl extends ToyStoreApplicationModuleImpl implements ToyStoreService {
  /**
   *
   * This is the default constructor (do not remove)
   */
  public ToyStoreServiceImpl() {}

  //--[Begin Custom Code]--
  private static final String REFRESHACCOUNT = "toystore.refreshaccountonedit";

  /**
   * Create a new order for the account whose name is passed in.
   *
   * NOTE: Orders view object has max fetch size == 0 to use for insert only
   *
   * @param currentUsername Name of the account placing the order
   */
  public void createNewOrder(String currentUsername) {
    /*
     * Before creating a new order (using the "Orders" view object which
     * is a detail of the "Accounts" view object, we want to double-check
     * that the Accounts view object has the current row that matches the
     * name of the currently logged on user. If the user has already placed
     * one order with us, and the "/thankyou" action has released our
     * application module in stateless mode, then if the still-logged-in
     * user continues to browse and wants to place another order, calling
     * this method will make sure that the currently logged-in user's
     * "Accounts" row is retrieved. This is important since the "Order"
     * entity object is strongly composed with the "Account" entity object,
     * so the creation of a new order that we are about to perform here
     * would fail with the "Unable to find/invalidate owning entity" exception
     * if the parent "Account" is not present as expected.
     */
    verifyThatCurrentUsersAccountInfoIsPresent(currentUsername);
    ViewObject orders = getOrders();
    Row newOrder = orders.first();
    if (newOrder == null) {
      Row newRow = orders.createRow();
      newRow.setNewRowState(Row.STATUS_INITIALIZED);
      orders.insertRow(newRow);
    }
  }
  private void verifyThatCurrentUsersAccountInfoIsPresent(
    String currentUsername) {
    AccountsRowImpl curUserAccount = (AccountsRowImpl) getAccounts().first();
    if ((curUserAccount == null) ||
          !curUserAccount.getUsername().equals(currentUsername)) {
      getAccounts().findAuthenticatedAccountByUsername(currentUsername);
      curUserAccount = (AccountsRowImpl) getAccounts().first();
    }
    AccountImpl acctPlacingOrder = curUserAccount.getAccount();
    /*
     * If the account placing the order is invalid, then refresh it
     * from the database to restore it to a valid state. The user could
     * get into this situation if after signing in, they visit the
     * "Edit Account Info" page, submit some invalid changes (like blanking
     * out a required field and leaving it blank), and then click on
     * their shopping cart icon and proceed with the checkout without
     * ever correcting their invalid submitted account info changes.
     */
    if (acctPlacingOrder.isInvalid()) {
      acctPlacingOrder.refresh(Entity.REFRESH_WITH_DB_FORGET_CHANGES);
    }
  }
  /**
   * Return true if the username/password combination represents a
   * valid signon that we have on file.
   *
   * @param username the username to validate
   * @param username their password
   * @return returns true if the username/password combination is valid
   */
  public boolean validSignon(String username, String password) {
    removeAnyInvalidNewAccounts();
    return getAccounts().findAccountByUsernamePassword(username, password);
  }
  /**
   * Purge any new but invalid AccountImpl (and associated SignInImpl) instances
   * from the Entity Cache. These could get into the system if the user visits
   * the "Register a New User" page, enters invalid data and submits, but
   * instead of fixing the invalid data, click on another link to sign-in
   * as another valid account instead.
   */
  private void removeAnyInvalidNewAccounts() {
    EntityDefImpl def = AccountImpl.getDefinitionObject();
    com.sun.java.util.collections.Iterator iter = def.getAllEntityInstancesIterator(getDBTransaction());
    while (iter.hasNext()) {
      AccountImpl acct = (AccountImpl) iter.next();
      if (acct.isInvalid() && (acct.getEntityState() == Entity.STATUS_NEW)) {
        acct.remove();
        acct.getSignon().remove();
      }
    }
  }
  /**
   * Add a single item to the shopping cart
   * @param itemid
   * @return
   */
  public void addItemToCart(String itemid) {
    adjustQuantityInCart(new String[]{itemid},new long[]{1});
  }
  public void removeItemFromCart(String itemid) {
    adjustQuantityInCart(new String[]{itemid},new long[]{0});
  }  
  /**
   * Takes an array of item ids and array of corresponding quantities
   * and adjusts the cart to contain those items in those quantities.
   *
   * @param itemid Array of item ids to add to the cart
   * @param qty    Array of quantity values to adjust in the cart
   * @return boolean indicating if the cart is empty as a result.
   */
  public boolean adjustQuantityInCart(String[] itemid, long[] qty) {
    ShoppingCartImpl cart = getShoppingCart();
    if (itemid != null) {
      int entries = itemid.length;
      for (int z = 0; z < entries; z++) {
        cart.adjustQuantityInCart(itemid[z], qty[z]);
      }
    }
    boolean isEmpty = cart.isCartEmpty();
    return isEmpty;
  }
  
  public void removeShoppingCartItemsWithZeroQuantity() {
    getShoppingCart().removeShoppingCartItemsWithZeroQuantity();
  }

  /**
   * Returns the number of items in the shopping cart for a given item id
   * Delegates to the functionality of the same name encapsulated on our
   * toystore.model.dataaccess.ShoppingCart view object component.
   *
   * @param itemid Item id whose in-cart-quantity you want to know
   * @return long quantity of given item in the cart
   */
  public long currentQuantityInCart(String itemid) {
    ShoppingCartImpl cart = getShoppingCart();
    return (itemid != null) ? cart.currentQuantityInCart(itemid) : 0;
  }
  public String finalizeOrder() {
    OrdersRowImpl newOrder = (OrdersRowImpl) getOrders().first();
    if (newOrder == null) {
      newOrder = (OrdersRowImpl) getOrders().createRow();
      getOrders().insertRow(newOrder);
    }
    /*
     * Use a secondary iterator to loop over the shopping cart rows
     * so as to not use the default iterator being used by the
     * ADF binding layer for rendering the shopping cart contents.
     */
    RowSetIterator cartItems = getShoppingCart().createRowSetIterator(null);
    List cartItemIds = new ArrayList(cartItems.getFetchedRowCount());
    while (cartItems.hasNext()) {
      cartItemIds.add(((ShoppingCartRowImpl) cartItems.next()).getItemid());
    }
    cartItems.closeRowSetIterator();
    Collections.sort(cartItemIds);
    Iterator cartItemIdsIterator = cartItemIds.iterator();
    double total = 0;
    int linenumber = 0;
    while (cartItemIdsIterator.hasNext()) {
      Key cartItemId = new Key(new Object[] { cartItemIdsIterator.next() });
      ShoppingCartRowImpl cartItem = (ShoppingCartRowImpl) getShoppingCart()
                                                             .findByKey(cartItemId,
          1)[0];
      LineItemsRowImpl newLine = (LineItemsRowImpl) newOrder.getLineItems()
                                                            .createRow();
      newLine.setLinenum(new Number(++linenumber));
      newLine.setItemid(cartItem.getItemid());
      long quantityOrdered = cartItem.getQuantity().longValue();
      newLine.setQuantity(new Number(quantityOrdered));
      ItemImpl itemBeingOrdered = newLine.getLineitem().getItem();
      Number listPrice = itemBeingOrdered.getListprice();
      newLine.setUnitprice(listPrice);
      total += (quantityOrdered * listPrice.doubleValue());
      newOrder.getLineItems().insertRow(newLine);
      // Decrement Inventory Quantity for current line item amount
      InventoryImpl inv = newLine.getLineitem().getItem().getInventory();
      prelockInventoryItem(inv);
      double currentQty = inv.getQty().doubleValue();
      double newQuantity = currentQty - (newLine.getQuantity().doubleValue());
      inv.setQty(newNumber(newQuantity));
    }
    newOrder.setTotalprice(newNumber(total));
    getDBTransaction().commit();
    getShoppingCart().emptyCart();
    getOrders().clearCache();
    getLineItems().clearCache();
    return newOrder.getOrderid().toString();
  }
  /**
   * Lock the inventory item and refresh the quantity from the database
   * if we get the RowInconsistentException.
   *
   * @param inv Inventory entity to lock.
   */
  private void prelockInventoryItem(InventoryImpl inv) {
    while (true) {
      try {
        /*
         * We've modified the Inventory entity object's cache
         * implementation in InventoryCollImpl.java to perform a
         * blocking FOR UPDATE lock instead of the normal
         * FOR UPDATE NOWAIT lock here.
         */
        inv.lockUnmodified();
        break;
      }
      catch (RowInconsistentException rex) {
        inv.refresh(Entity.REFRESH_WITH_DB_FORGET_CHANGES);
      }
    }
  }
  /**
   * Return true if shopping cart is empty
   */
  public boolean isCartEmpty() {
    return getShoppingCart().isCartEmpty();
  }

  public Double getCartTotal() {
    return new Double(getShoppingCart().cartTotal());
  }
  public boolean prepareToEditAccountInfoFor(String username) {
    Key k = new Key(new Object[] { username });
    ViewObject vo = getAccounts();
    /*
     * We don't want the view object to execute any other query
     * than the one row we will be finding by key, so we mark
     * its max fetch size to zero.
     */
    vo.setMaxFetchSize(0);
    Row[] r = vo.findByKey(k, 1);
    if (r.length < 1) {
      return false;
    }
    Row rowFound = r[0];
    /*
     * Refresh the account data from the database to handle the
     * case that the same user is modifying their account from
     * different browsers sessions.
     */
    if (getConfigurationProperty(REFRESHACCOUNT).equalsIgnoreCase("true")) {
      rowFound.refresh(Row.REFRESH_WITH_DB_ONLY_IF_UNCHANGED);
    }
    /*
     * Set the row we found as the current row in the VO
     */
    vo.setCurrentRow(rowFound);
    return true;
  }
  public void prepareToCreateNewAccount() {
    ViewObject vo = getAccounts();
    vo.clearCache();
    removeAnyInvalidNewAccounts();
    /*
     * Mark the view object as insert only by setting
     * it's max fetch size to zero. Executing the query
     * when the max fetch size is zero won't actually
     * perform any query, but will mark the VO as
     * executed so the ADF binding layer will know it
     * doesn't need to re-execute it later.
     */
    vo.setMaxFetchSize(0);
    vo.executeQuery();
    Row newRow = vo.createRow();
    vo.insertRow(newRow);
    newRow.setNewRowState(Row.STATUS_INITIALIZED);
    vo.setCurrentRow(newRow);
  }
  private Number newNumber(double d) {
    try {
      return new Number(d);
    }
    catch (SQLException s) {
      return null;
    }
  }
  protected void prepareSession(Session session) {
    super.prepareSession(session);
    /*
     * We use the accounts view only for creating new accounts
     * and for looking up an existing user account upon signin.
     */
    getAccounts().setMaxFetchSize(0);
  }
  //--[End Custom Code]--
  /**
   *
   * Sample main for debugging Business Components code using the tester.
   */
  public static void main(String[] args) {
    launchTester("toystore.model.services", /* Package Name       */
      "ToyStoreServiceLocal"); /* Configuration Name */
  }
  /**
   *
   * Container's getter for ProductList
   */
  public ViewObjectImpl getProductList() {
    return (ViewObjectImpl)findViewObject("ProductList");
  }
  /**
   *
   * Container's getter for ItemsForSale
   */
  public ItemsForSaleImpl getItemsForSale() {
    return (ItemsForSaleImpl)findViewObject("ItemsForSale");
  }
  /**
   *
   * Container's getter for Accounts
   */
  public AccountsImpl getAccounts() {
    return (AccountsImpl)findViewObject("Accounts");
  }
  /**
   *
   * Container's getter for Orders
   */
  public ViewObjectImpl getOrders() {
    return (ViewObjectImpl)findViewObject("Orders");
  }
  /**
   *
   * Container's getter for LineItems
   */
  public ViewObjectImpl getLineItems() {
    return (ViewObjectImpl)findViewObject("LineItems");
  }
  /**
   *
   * Container's getter for FindProducts
   */
  public ViewObjectImpl getFindProducts() {
    return (ViewObjectImpl)findViewObject("FindProducts");
  }

  /**
   *
   * Container's getter for ReviewOrder
   */
  public ReviewOrderImpl getReviewOrder() {
    return (ReviewOrderImpl)findViewObject("ReviewOrder");
  }
  /**
   *
   * Container's getter for ReviewLineItems
   */
  public ViewObjectImpl getReviewLineItems() {
    return (ViewObjectImpl)findViewObject("ReviewLineItems");
  }
  /**
   *
   * Container's getter for CountryList
   */
  public PropertyFileBasedLookupViewObjectImpl getCountryList() {
    return (PropertyFileBasedLookupViewObjectImpl)findViewObject("CountryList");
  }
  /**
   *
   * Container's getter for CreditCardList
   */
  public PropertyFileBasedLookupViewObjectImpl getCreditCardList() {
    return (PropertyFileBasedLookupViewObjectImpl)findViewObject("CreditCardList");
  }
  /**
   *
   * Container's getter for ExpirationYearList
   */
  public PropertyFileBasedLookupViewObjectImpl getExpirationYearList() {
    return (PropertyFileBasedLookupViewObjectImpl)findViewObject("ExpirationYearList");
  }
  /**
   *
   * Container's getter for ShippingOptionsList
   */
  public PropertyFileBasedLookupViewObjectImpl getShippingOptionsList() {
    return (PropertyFileBasedLookupViewObjectImpl)findViewObject("ShippingOptionsList");
  }
  /**
   *
   * Container's getter for ItemsOfProductKind
   */
  public ViewLinkImpl getItemsOfProductKind() {
    return (ViewLinkImpl)findViewLink("ItemsOfProductKind");
  }
  /**
   *
   * Container's getter for AccountPlacingOrder
   */
  public ViewLinkImpl getAccountPlacingOrder() {
    return (ViewLinkImpl)findViewLink("AccountPlacingOrder");
  }
  /**
   *
   * Container's getter for OrderLines
   */
  public ViewLinkImpl getOrderLines() {
    return (ViewLinkImpl)findViewLink("OrderLines");
  }
  /**
   *
   * Container's getter for ReviewLinesForOrder
   */
  public ViewLinkImpl getReviewLinesForOrder() {
    return (ViewLinkImpl)findViewLink("ReviewLinesForOrder");
  }
  /**
   *
   * Container's getter for ProductsInCategory
   */
  public ViewObjectImpl getProductsInCategory() {
    return (ViewObjectImpl)findViewObject("ProductsInCategory");
  }
  /**
   *
   * Container's getter for ShoppingCart
   */
  public ShoppingCartImpl getShoppingCart() {
    return (ShoppingCartImpl)findViewObject("ShoppingCart");
  }
  /**
   *
   * Container's getter for ShoppingCartItemLookup
   */
  public ViewObjectImpl getShoppingCartItemLookup() {
    return (ViewObjectImpl)findViewObject("ShoppingCartItemLookup");
  }
}
