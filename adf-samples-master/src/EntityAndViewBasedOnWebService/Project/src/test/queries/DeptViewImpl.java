/* Copyright 2010, 2017, Oracle and/or its affiliates. All rights reserved. */
package test.queries;
import java.rmi.RemoteException;

import java.sql.ResultSet;
import java.sql.SQLException;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import oracle.jbo.AttributeDef;
import oracle.jbo.JboException;
import oracle.jbo.Row;
import oracle.jbo.ViewCriteria;
import oracle.jbo.domain.Number;
import oracle.jbo.server.SQLBuilder;
import oracle.jbo.server.ViewObjectImpl;
import oracle.jbo.server.ViewRowImpl;
import oracle.jbo.server.ViewRowSetImpl;

import remoteservices.DeptServiceSoapHttpPortClient;

import remoteservices.types.deptws.server.webservice.types.Department;
// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class DeptViewImpl extends ViewObjectImpl {
  /**This is the default constructor (do not remove)
   */
  public DeptViewImpl() {
  }
  protected void executeQueryForCollection(Object qc, Object[] params, 
                                           int numUserParams) {
    storeNewDepartmentArrayIterator(qc, 
                                   retrieveDepartmentArrayFromWebService(qc, params));
    super.executeQueryForCollection(qc, params, numUserParams);
  }

  /**
   * Overridden framework method.
   *
   * Wipe out all traces of a built-in query for this VO
   */
  protected void create() {
    getViewDef().setQuery(null);
    getViewDef().setSelectClause(null);
    setQuery(null);
  }

  /**
   * Overridden framework method.
   *
   * The role of this method is to "fetch", populate, and return a single row
   * from the datasource by calling createNewRowForCollection() and populating
   * its attributes using populateAttributeForRow().
   */
  protected ViewRowImpl createRowFromResultSet(Object qc, ResultSet rs) {
    Iterator departments = getDepartmentArrayIterator(qc);
    ViewRowImpl r = createNewRowForCollection(qc);
    Department curDept = (Department)departments.next();
    populateAttributeForRow(r, findAttributeDef("Deptno").getIndex(), newNumber(curDept.getDeptno()));
    populateAttributeForRow(r, findAttributeDef("Dname").getIndex(), curDept.getDname());
    populateAttributeForRow(r, findAttributeDef("Loc").getIndex(), curDept.getLoc());
    return r;
  }
  private Number newNumber(Integer i) {
    try {
      return new Number(i);
    } catch (SQLException e) {
      e.printStackTrace();
      return null;
    }
  }
  /**
   * Overridden framework method.
   *
   * Return true if the datasource has at least one more record to fetch.
   */
  protected boolean hasNextForCollection(Object qc) {
    /*
     * When were at the end of the result set, mark the query collection
     * as "FetchComplete".
     */
    boolean hasNext = getDepartmentArrayIterator(qc).hasNext();
    if (!hasNext) {
      setFetchCompleteForCollection(qc, true);
    }
    return hasNext;
  }
  protected void releaseUserDataForCollection(Object qc, Object rs) {
    super.releaseUserDataForCollection(qc, rs);
  }

  /**
   * Overridden framework method
   *
   * Return the number of rows that would be returned by executing
   * the query implied by the datasource. This gives the developer a
   * chance to perform a fast count of the rows that would be retrieved
   * if all rows were fetched from the database. In the default implementation
   * the framework will perform a SELECT COUNT(*) FROM (...) wrapper query
   * to let the database return the count. This count might only be an estimate
   * depending on how resource-intensive it would be to actually count the rows.
   */
  public long getQueryHitCount(ViewRowSetImpl viewRowSet) {
    return retrieveEstimatedCountFromWebService(viewRowSet);
  }
  // ------------- PRIVATE METHODS ----------------
  private Map viewCriteriaAsMap() {
    Map ret = new HashMap();
    ViewCriteria vc = getViewCriteria();
    if (vc != null && vc.size() > 0) {
      Row vcr = vc.first();
      for (AttributeDef attr: getAttributeDefs()) {
        String s = (String)vcr.getAttribute(attr.getName());
        if (s != null && s != "") {
          ret.put(attr.getName(), s);
        }
      }
    }
    return ret;
  }
  private long retrieveEstimatedCountFromWebService(ViewRowSetImpl vrs) {
    try {
      if (vrs.isFetchComplete()) {
        return vrs.getFetchedRowCount();
      }
      DeptServiceSoapHttpPortClient am = 
        new DeptServiceSoapHttpPortClient();
      return am.estimateCount(viewCriteriaAsMap());
    } catch (RemoteException e) {
      e.printStackTrace();
      throw new JboException("Failed");
    } catch (Exception e) {
      e.printStackTrace();
      throw new JboException("Failed");
    }
  }
  private Department[] retrieveDepartmentArrayFromWebService(Object qc, 
                                                           Object[] params) {
    try {
      DeptServiceSoapHttpPortClient am = 
        new DeptServiceSoapHttpPortClient();
      return am.retrieveDepartmentData(viewCriteriaAsMap());
    } catch (RemoteException e) {
      e.printStackTrace();
      throw new JboException("Failed");
    } catch (Exception e) {
      e.printStackTrace();
      throw new JboException("Failed");
    }
  }
  private Object getNamedBindParamValue(String varName, Object[] params) {
    Object result = null;
    if (getBindingStyle() == SQLBuilder.BINDING_STYLE_ORACLE_NAME) {
      if (params != null) {
        for (Object param: params) {
          Object[] nameValue = (Object[])param;
          String name = (String)nameValue[0];
          if (name.equals(varName)) {
            return (String)nameValue[1];
          }
        }
      }
    }
    throw new JboException("No bind variable named '" + varName + "'");
  }

  /**
   * Store a new result set in the query-collection-private user-data context
   */
  private void storeNewDepartmentArrayIterator(Object qc, Department[] rs) {
    setUserDataForCollection(qc, Arrays.asList(rs).iterator());
    hasNextForCollection(qc); // Prime the pump with the first row.
  }

  /**
   * Retrieve the result set wrapper from the query-collection user-data
   */
  private Iterator getDepartmentArrayIterator(Object qc) {
    return (Iterator)getUserDataForCollection(qc);
  }   
}
